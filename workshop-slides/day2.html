<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>T3 Workshop ‚Äî Day 2: tRPC</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Instrument+Serif:ital@0;1&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>

<nav>
  <div class="logo"><b>T3</b>&thinsp;WORKSHOP</div>
  <div class="nav-links">
    <a href="index.html">Day 1</a>
    <a href="day2.html" class="active">Day 2</a>
    <a href="day3.html">Day 3</a>
  </div>
</nav>

<main>
<!-- ‚ïê‚ïê‚ïê HERO ‚ïê‚ïê‚ïê -->
<header class="hero">
  <div class="hero-inner">
    <div class="tag"><span class="dot"></span> Session 2 &middot; Week 1</div>
    <h1>Your backend is<br>just <em>functions.</em></h1>
    <p class="subtitle">
      tRPC gives you typed functions your frontend calls directly.
      Like an internal SDK that writes itself.
    </p>
    <div class="cta-group">
      <a href="#s2" class="btn btn-primary">Begin Day 2 &darr;</a>
      <a href="day3.html" class="btn btn-ghost">Skip to Day 3 &rarr;</a>
    </div>
    <div class="tech-bar">
      <span class="tech-label">Powered by</span>
      <div class="logos">
        <img src="assets/prisma.svg" alt="Prisma" title="Prisma">
        <img src="assets/trpc.png" alt="tRPC" title="tRPC" style="border-radius:50%;">
        <img src="assets/nextjs.png" alt="Next.js" title="Next.js" style="border-radius:50%;">
        <img src="assets/typescript.svg" alt="TypeScript" title="TypeScript">
        <img src="assets/tailwindcss.svg" alt="Tailwind" title="Tailwind CSS">
        <img src="assets/tanstack.png" alt="TanStack" title="TanStack Query" style="border-radius:50%;">
      </div>
    </div>
  </div>
</header>

<!-- ‚ïê‚ïê‚ïê WHAT IS ZOD ‚ïê‚ïê‚ïê -->
<div class="slide reveal" id="s2" data-num="01">
  <div class="slide-label"><span class="line"></span> 10 min</div>
  <h2>What is Zod?</h2>
  <p>
    A schema validation library for TypeScript. One definition gives you
    <strong style="color:var(--accent);">runtime validation</strong> and a
    <strong style="color:var(--teal);">TypeScript type</strong> ‚Äî no duplication.
  </p>

  <div class="cols">
    <div class="reveal">
      <h3>The problem it solves</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">without-zod.ts</span>
        </div>
        <pre><span class="cm">// You write the type‚Ä¶</span>
<span class="kw">interface</span> <span class="tp">TaskInput</span> {
  <span class="pr">title</span>: <span class="tp">string</span>;
  <span class="pr">priority</span>: <span class="str">"LOW"</span> | <span class="str">"MEDIUM"</span> | <span class="str">"HIGH"</span>;
}

<span class="cm">// ‚Ä¶then write validation AGAIN</span>
<span class="kw">function</span> <span class="fn">validate</span>(<span class="pr">data</span>: <span class="tp">unknown</span>) {
  <span class="kw">if</span> (<span class="kw">typeof</span> data.title !== <span class="str">"string"</span>)
    <span class="kw">throw new</span> <span class="tp">Error</span>(<span class="str">"bad title"</span>);
  <span class="kw">if</span> (data.title.length === <span class="num">0</span>)
    <span class="kw">throw new</span> <span class="tp">Error</span>(<span class="str">"empty"</span>);
  <span class="cm">// ...repeat for every field üò©</span>
}
<span class="cm">// Two sources of truth. They WILL drift.</span></pre>
      </div>
    </div>
    <div class="reveal">
      <h3>With Zod</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">with-zod.ts</span>
        </div>
        <pre><span class="kw">import</span> { z } <span class="kw">from</span> <span class="str">"zod"</span>;

<span class="cm">// One definition = validation + type</span>
<span class="kw">const</span> <span class="tp">TaskInput</span> = z.<span class="fn">object</span>({
  <span class="pr">title</span>: z.<span class="fn">string</span>().<span class="fn">min</span>(<span class="num">1</span>),
  <span class="pr">priority</span>: z.<span class="fn">enum</span>([
    <span class="str">"LOW"</span>, <span class="str">"MEDIUM"</span>, <span class="str">"HIGH"</span>
  ]),
});

<span class="cm">// Extract the TS type for free</span>
<span class="kw">type</span> <span class="tp">TaskInput</span> = z.<span class="fn">infer</span>&lt;
  <span class="kw">typeof</span> <span class="tp">TaskInput</span>
&gt;;
<span class="cm">// ‚Üí { title: string; priority: "LOW" | ‚Ä¶ }</span>

<span class="cm">// Runtime check:</span>
<span class="tp">TaskInput</span>.<span class="fn">parse</span>(data); <span class="cm">// throws if bad</span>
<span class="tp">TaskInput</span>.<span class="fn">safeParse</span>(data); <span class="cm">// returns result</span></pre>
      </div>
    </div>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê ZOD BUILDING BLOCKS ‚ïê‚ïê‚ïê -->
<div class="slide reveal" data-num="01.5">
  <div class="slide-label"><span class="line"></span> Zod &middot; continued</div>
  <h2>Zod building blocks</h2>
  <p>
    You'll use these every time you write a tRPC procedure. There are more in the docs ‚Äî
    these are the ones that matter today.
  </p>

  <div class="cols">
    <div class="reveal">
      <h3>Primitives &amp; modifiers</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">primitives.ts</span>
        </div>
        <pre><span class="cm">// Strings</span>
z.<span class="fn">string</span>()                 <span class="cm">// any string</span>
z.<span class="fn">string</span>().<span class="fn">min</span>(<span class="num">1</span>)          <span class="cm">// non-empty</span>
z.<span class="fn">string</span>().<span class="fn">email</span>()         <span class="cm">// valid email</span>
z.<span class="fn">string</span>().<span class="fn">url</span>()           <span class="cm">// valid URL</span>

<span class="cm">// Numbers</span>
z.<span class="fn">number</span>()                 <span class="cm">// any number</span>
z.<span class="fn">number</span>().<span class="fn">int</span>().<span class="fn">positive</span>() <span class="cm">// &gt; 0 integer</span>
z.<span class="fn">number</span>().<span class="fn">min</span>(<span class="num">0</span>).<span class="fn">max</span>(<span class="num">100</span>)  <span class="cm">// range</span>

<span class="cm">// Others</span>
z.<span class="fn">boolean</span>()                <span class="cm">// true/false</span>
z.<span class="fn">date</span>()                   <span class="cm">// Date object</span>

<span class="cm">// Modifiers ‚Äî work on any type</span>
z.<span class="fn">string</span>().<span class="fn">optional</span>()      <span class="cm">// string | undefined</span>
z.<span class="fn">string</span>().<span class="fn">nullable</span>()      <span class="cm">// string | null</span>
z.<span class="fn">string</span>().<span class="fn">default</span>(<span class="str">"hi"</span>)   <span class="cm">// defaults if absent</span></pre>
      </div>
    </div>
    <div class="reveal">
      <h3>Composing schemas</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">composed.ts</span>
        </div>
        <pre><span class="cm">// Enums ‚Äî exact string unions</span>
z.<span class="fn">enum</span>([<span class="str">"LOW"</span>, <span class="str">"MEDIUM"</span>, <span class="str">"HIGH"</span>])
<span class="cm">// ‚Üí "LOW" | "MEDIUM" | "HIGH"</span>

<span class="cm">// Objects ‚Äî your main building block</span>
<span class="kw">const</span> <span class="tp">CreateTask</span> = z.<span class="fn">object</span>({
  <span class="pr">title</span>:     z.<span class="fn">string</span>().<span class="fn">min</span>(<span class="num">1</span>),
  <span class="pr">priority</span>:  z.<span class="fn">enum</span>([<span class="str">"LOW"</span>, <span class="str">"MEDIUM"</span>, <span class="str">"HIGH"</span>]),
  <span class="pr">projectId</span>: z.<span class="fn">string</span>(),
});

<span class="cm">// Extend an existing schema</span>
<span class="kw">const</span> <span class="tp">UpdateTask</span> = z.<span class="fn">object</span>({
  <span class="pr">id</span>:    z.<span class="fn">string</span>(),
  <span class="pr">title</span>: z.<span class="fn">string</span>().<span class="fn">min</span>(<span class="num">1</span>).<span class="fn">optional</span>(),
  <span class="pr">priority</span>: z.<span class="fn">enum</span>([<span class="str">"LOW"</span>, <span class="str">"MEDIUM"</span>, <span class="str">"HIGH"</span>])
    .<span class="fn">optional</span>(),
});

<span class="cm">// Arrays</span>
z.<span class="fn">array</span>(z.<span class="fn">string</span>())  <span class="cm">// string[]</span>
z.<span class="fn">string</span>().<span class="fn">array</span>()  <span class="cm">// same thing</span></pre>
      </div>
    </div>
  </div>

  <div class="callout ok reveal" style="margin-top:1.5rem;">
    <h4>Why this matters for tRPC</h4>
    <p>Contract-first procedures use <span class="c">.input(zodSchema)</span> and <span class="c">.output(zodSchema)</span>.
    Zod validates both ends at runtime while TypeScript infers both types automatically.</p>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê tRPC VOCABULARY ‚ïê‚ïê‚ïê -->
<div class="slide reveal" data-num="02">
  <div class="slide-label"><span class="line"></span> 10 min</div>
  <h2>The tRPC vocabulary</h2>
  <p>
    Six terms. Once you know them, every tRPC codebase reads the same way.
  </p>

  <div class="pain-grid reveal-stagger" style="grid-template-columns: 1fr 1fr 1fr;">
    <div class="pain-item">
      <div class="pain-icon" style="color:var(--accent);">fn</div>
      <h4>Procedure</h4>
      <p>A single API endpoint ‚Äî a function the client can call. Can be a query, mutation, or subscription.</p>
    </div>
    <div class="pain-item">
      <div class="pain-icon" style="color:var(--teal);">{}</div>
      <h4>Router</h4>
      <p>A group of related procedures under one namespace. Like <span class="c">taskRouter</span> containing <span class="c">getAll</span>, <span class="c">create</span>, etc.</p>
    </div>
    <div class="pain-item">
      <div class="pain-icon" style="color:var(--lavender);">Q</div>
      <h4>Query</h4>
      <p>A procedure that <strong style="color:var(--tx);">reads</strong> data. Think GET. Uses <span class="c">.query()</span>. Called with <span class="c">useQuery()</span> on the client.</p>
    </div>
    <div class="pain-item">
      <div class="pain-icon" style="color:var(--peach);">M</div>
      <h4>Mutation</h4>
      <p>A procedure that <strong style="color:var(--tx);">writes</strong> data. Think POST/PUT/DELETE. Uses <span class="c">.mutation()</span>. Called with <span class="c">useMutation()</span>.</p>
    </div>
    <div class="pain-item">
      <div class="pain-icon" style="color:var(--coral);">ctx</div>
      <h4>Context</h4>
      <p>Shared state every procedure can access ‚Äî database connection, session, headers. Created once per request.</p>
    </div>
    <div class="pain-item">
      <div class="pain-icon" style="color:var(--accent);">mw</div>
      <h4>Middleware</h4>
      <p>Runs before a procedure. Can check auth, log, or add data to context. Chains with <span class="c">.use()</span>.</p>
    </div>
  </div>

  <div class="callout reveal" style="margin-top:1.5rem;">
    <h4>REST mental bridge</h4>
    <p><span class="c">GET /api/tasks</span> &rarr; <span class="c">api.task.getAll.useQuery()</span>.&ensp;
    <span class="c">POST /api/tasks</span> &rarr; <span class="c">api.task.create.useMutation()</span>.&ensp;
    Same thing ‚Äî but the compiler checks every call.</p>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê HOW THEY FIT TOGETHER ‚ïê‚ïê‚ïê -->
<div class="slide reveal" data-num="02.5">
  <div class="slide-label"><span class="line"></span> tRPC &middot; architecture</div>
  <h2>How the pieces fit together</h2>

  <div class="cols">
    <div class="reveal">
      <h3>Context ‚Äî shared state</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">src/server/api/trpc.ts</span>
        </div>
        <pre><span class="cm">// Created once per request</span>
<span class="kw">export const</span> <span class="fn">createTRPCContext</span> =
  <span class="kw">async</span> (opts: { <span class="pr">headers</span>: <span class="tp">Headers</span> }) =&gt; {
    <span class="kw">return</span> {
      <span class="pr">db</span>,         <span class="cm">// Prisma client</span>
      ...opts,    <span class="cm">// headers, etc.</span>
    };
  };

<span class="cm">// Every procedure gets ctx automatically:</span>
<span class="cm">//   ctx.db    ‚Üí query the database</span>
<span class="cm">//   ctx.headers ‚Üí read request headers</span></pre>
      </div>

      <h3 style="margin-top:1.5rem;">Middleware ‚Äî intercept &amp; extend</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">middleware</span>
        </div>
        <pre><span class="cm">// Runs BEFORE the procedure</span>
<span class="kw">const</span> <span class="fn">isAuthed</span> = t.<span class="fn">middleware</span>(({ <span class="pr">ctx</span>, <span class="pr">next</span> }) =&gt; {
  <span class="kw">if</span> (!ctx.session?.user)
    <span class="kw">throw new</span> <span class="tp">TRPCError</span>({
      <span class="pr">code</span>: <span class="str">"UNAUTHORIZED"</span>,
    });

  <span class="cm">// Pass enriched context downstream</span>
  <span class="kw">return</span> <span class="fn">next</span>({
    <span class="pr">ctx</span>: { <span class="pr">user</span>: ctx.session.user },
  });
});

<span class="cm">// Create a reusable procedure base</span>
<span class="kw">export const</span> <span class="tp">protectedProcedure</span> =
  t.procedure.<span class="fn">use</span>(<span class="fn">isAuthed</span>);</pre>
      </div>
    </div>
    <div class="reveal">
      <h3>Router ‚Äî group procedures</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">src/server/api/root.ts</span>
        </div>
        <pre><span class="kw">import</span> { <span class="fn">taskRouter</span> } <span class="kw">from</span> <span class="str">"./routers/task"</span>;
<span class="kw">import</span> { <span class="fn">projectRouter</span> } <span class="kw">from</span> <span class="str">"./routers/project"</span>;

<span class="kw">export const</span> <span class="fn">appRouter</span> = <span class="fn">createTRPCRouter</span>({
  <span class="pr">task</span>:    <span class="fn">taskRouter</span>,
  <span class="pr">project</span>: <span class="fn">projectRouter</span>,
});

<span class="cm">// Client calls become:</span>
<span class="cm">//   api.task.getAll.useQuery()</span>
<span class="cm">//   api.project.create.useMutation()</span>
<span class="cm">// ‚Üë namespace comes from the key name</span></pre>
      </div>

      <h3 style="margin-top:1.5rem;">Query vs Mutation</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">query-vs-mutation.ts</span>
        </div>
        <pre><span class="cm">// QUERY ‚Äî reads data. Cached by TanStack.</span>
<span class="fn">getAll</span>: publicProcedure
  .<span class="fn">output</span>(z.<span class="fn">array</span>(z.<span class="fn">object</span>({
    <span class="pr">id</span>: z.<span class="fn">string</span>(),
    <span class="pr">title</span>: z.<span class="fn">string</span>(),
  })))
  .<span class="fn">query</span>(({ <span class="pr">ctx</span> }) =&gt;
    ctx.db.task.<span class="fn">findMany</span>()
  ),

<span class="cm">// MUTATION ‚Äî writes data. Invalidates cache.</span>
<span class="fn">create</span>: publicProcedure
  .<span class="fn">input</span>(z.<span class="fn">object</span>({ <span class="pr">title</span>: z.<span class="fn">string</span>() }))
  .<span class="fn">output</span>(z.<span class="fn">object</span>({
    <span class="pr">id</span>: z.<span class="fn">string</span>(),
    <span class="pr">title</span>: z.<span class="fn">string</span>(),
  }))
  .<span class="fn">mutation</span>(({ <span class="pr">ctx</span>, <span class="pr">input</span> }) =&gt;
    ctx.db.task.<span class="fn">create</span>({ <span class="pr">data</span>: input })
  ),

<span class="cm">// Rule of thumb:</span>
<span class="cm">//   Contract first ‚Üí .input(...) + .output(...)</span>
<span class="cm">//   Then choose ‚Üí .query() or .mutation()</span></pre>
      </div>
    </div>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê ANATOMY OF A PROCEDURE ‚ïê‚ïê‚ïê -->
<div class="slide reveal" data-num="03">
  <div class="slide-label"><span class="line"></span> 10 min</div>
  <h2>Anatomy of a procedure</h2>
  <p>Every procedure is a contract-first chain: define input/output contracts, then implement resolver logic.</p>

  <div class="terminal reveal">
    <div class="terminal-chrome">
      <div class="dots"><span></span><span></span><span></span></div>
      <span class="file">src/server/api/routers/task.ts ‚Äî annotated</span>
    </div>
    <pre><span class="fn">create</span>: <span class="tp">publicProcedure</span>            <span class="cm">// ‚ù∂ Base ‚Äî public or protected</span>

  .<span class="fn">input</span>(z.<span class="fn">object</span>({                 <span class="cm">// ‚ù∑ Input ‚Äî Zod validates at runtime</span>
    <span class="pr">title</span>: z.<span class="fn">string</span>().<span class="fn">min</span>(<span class="num">1</span>,        <span class="cm">//    Bad data never reaches your DB</span>
      <span class="str">"Title is required"</span>),        <span class="cm">//    Custom error messages</span>
    <span class="pr">priority</span>: z.<span class="fn">enum</span>([              <span class="cm">//    Enum = exact string union</span>
      <span class="str">"LOW"</span>, <span class="str">"MEDIUM"</span>, <span class="str">"HIGH"</span>
    ]).<span class="fn">default</span>(<span class="str">"MEDIUM"</span>),          <span class="cm">//    Default if not provided</span>
    <span class="pr">projectId</span>: z.<span class="fn">string</span>(),
  }))

  .<span class="fn">output</span>(z.<span class="fn">object</span>({                <span class="cm">// ‚ù∏ Output ‚Äî response contract</span>
    <span class="pr">id</span>: z.<span class="fn">string</span>(),
    <span class="pr">title</span>: z.<span class="fn">string</span>(),
    <span class="pr">priority</span>: z.<span class="fn">enum</span>([<span class="str">"LOW"</span>, <span class="str">"MEDIUM"</span>, <span class="str">"HIGH"</span>]),
    <span class="pr">projectId</span>: z.<span class="fn">string</span>(),
  }))

  .<span class="fn">mutation</span>(                         <span class="cm">// ‚ùπ Type ‚Äî .query() reads, .mutation() writes</span>
    <span class="kw">async</span> ({ <span class="pr">ctx</span>, <span class="pr">input</span> }) =&gt; {     <span class="cm">// ‚ù∫ Resolver function</span>
                                      <span class="cm">//    ctx   = context (db, session, headers)</span>
                                      <span class="cm">//    input = validated &amp; typed by Zod ‚úì</span>
      <span class="kw">return</span> ctx.db.task.<span class="fn">create</span>({   <span class="cm">// ‚ùª Prisma ‚Äî typed DB query</span>
        <span class="pr">data</span>: {
          <span class="pr">title</span>: input.title,
          <span class="pr">priority</span>: input.priority,
          <span class="pr">projectId</span>: input.projectId,
        },
      });                             <span class="cm">// ‚ùº Return ‚Äî checked against .output contract</span>
    }
  ),</pre>
  </div>

  <div class="pain-grid reveal-stagger" style="margin-top:1.5rem; grid-template-columns: 1fr 1fr 1fr;">
    <div class="pain-item">
      <div class="pain-icon" style="color:var(--accent);">&#10102;</div>
      <h4>Base procedure</h4>
      <p><span class="c">publicProcedure</span> ‚Äî anyone can call it. <span class="c">protectedProcedure</span> ‚Äî requires auth. The middleware runs here.</p>
    </div>
    <div class="pain-item">
      <div class="pain-icon" style="color:var(--teal);">&#10103;</div>
      <h4>Input + output contract</h4>
      <p><span class="c">.input(...)</span> validates request shape and <span class="c">.output(...)</span> validates response shape. Types are inferred on both sides.</p>
    </div>
    <div class="pain-item">
      <div class="pain-icon" style="color:var(--lavender);">&#10104;&#10105;</div>
      <h4>Resolver + Return</h4>
      <p>Your business logic. <span class="c">ctx</span> gives you the DB. Whatever you return becomes the client's response type.</p>
    </div>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê FULL CRUD ‚ïê‚ïê‚ïê -->
<div class="slide reveal" data-num="04">
  <div class="slide-label"><span class="line"></span> 35 min live coding</div>
  <h2>Full CRUD router</h2>

  <div class="terminal reveal">
    <div class="terminal-chrome">
      <div class="dots"><span></span><span></span><span></span></div>
      <span class="file">src/server/api/routers/task.ts</span>
    </div>
    <pre><span class="kw">import</span> { z } <span class="kw">from</span> <span class="str">"zod"</span>;
<span class="kw">import</span> { <span class="tp">createTRPCRouter</span>, <span class="tp">publicProcedure</span> } <span class="kw">from</span> <span class="str">"~/server/api/trpc"</span>;
<span class="kw">import</span> {
  <span class="tp">TaskForListSchema</span>,
  <span class="tp">TaskCreateInputSchema</span>,
  <span class="tp">TaskUpdateInputSchema</span>,
  <span class="tp">TaskDeleteInputSchema</span>,
} <span class="kw">from</span> <span class="str">"~/types/task"</span>;

<span class="kw">const</span> <span class="tp">TaskMutationResultSchema</span> = z.<span class="fn">object</span>({
  <span class="pr">id</span>: z.<span class="fn">string</span>(),
  <span class="pr">title</span>: z.<span class="fn">string</span>(),
  <span class="pr">priority</span>: z.<span class="fn">enum</span>([<span class="str">"LOW"</span>, <span class="str">"MEDIUM"</span>, <span class="str">"HIGH"</span>]),
  <span class="pr">status</span>: z.<span class="fn">enum</span>([<span class="str">"TODO"</span>, <span class="str">"IN_PROGRESS"</span>, <span class="str">"DONE"</span>]),
  <span class="pr">projectId</span>: z.<span class="fn">string</span>(),
});

<span class="kw">export const</span> <span class="fn">taskRouter</span> = <span class="fn">createTRPCRouter</span>({
  <span class="fn">getAll</span>: <span class="tp">publicProcedure</span>
    .<span class="fn">output</span>(z.<span class="fn">array</span>(<span class="tp">TaskForListSchema</span>))
    .<span class="fn">query</span>(<span class="kw">async</span> ({ <span class="pr">ctx</span> }) =&gt; {
      <span class="kw">const</span> tasks = <span class="kw">await</span> ctx.db.task.<span class="fn">findMany</span>({
        <span class="pr">include</span>: { <span class="pr">project</span>: <span class="kw">true</span>, <span class="pr">user</span>: <span class="kw">true</span> },
        <span class="pr">orderBy</span>: { <span class="pr">createdAt</span>: <span class="str">"desc"</span> },
      });
      <span class="kw">return</span> tasks.<span class="fn">map</span>((t) =&gt; ({
        ...t,
        <span class="pr">project</span>: { <span class="pr">id</span>: t.project.id, <span class="pr">name</span>: t.project.name },
        <span class="pr">user</span>: t.user ? { <span class="pr">id</span>: t.user.id, <span class="pr">name</span>: t.user.name } : <span class="kw">null</span>,
      }));
    }),

  <span class="fn">create</span>: <span class="tp">publicProcedure</span>
    .<span class="fn">input</span>(<span class="tp">TaskCreateInputSchema</span>)
    .<span class="fn">output</span>(<span class="tp">TaskMutationResultSchema</span>)
    .<span class="fn">mutation</span>(({ <span class="pr">ctx</span>, <span class="pr">input</span> }) =&gt;
      ctx.db.task.<span class="fn">create</span>({ <span class="pr">data</span>: input }),
    ),

  <span class="fn">update</span>: <span class="tp">publicProcedure</span>
    .<span class="fn">input</span>(<span class="tp">TaskUpdateInputSchema</span>)
    .<span class="fn">output</span>(<span class="tp">TaskMutationResultSchema</span>)
    .<span class="fn">mutation</span>(({ <span class="pr">ctx</span>, <span class="pr">input</span> }) =&gt; {
      <span class="kw">const</span> { <span class="pr">id</span>, ...<span class="pr">data</span> } = input;
      <span class="kw">return</span> ctx.db.task.<span class="fn">update</span>({ <span class="pr">where</span>: { id }, <span class="pr">data</span> });
    }),

  <span class="fn">delete</span>: <span class="tp">publicProcedure</span>
    .<span class="fn">input</span>(<span class="tp">TaskDeleteInputSchema</span>)
    .<span class="fn">output</span>(<span class="tp">TaskMutationResultSchema</span>)
    .<span class="fn">mutation</span>(({ <span class="pr">ctx</span>, <span class="pr">input</span> }) =&gt;
      ctx.db.task.<span class="fn">delete</span>({ <span class="pr">where</span>: { <span class="pr">id</span>: input.id } })
    ),
});</pre>
  </div>

  <div class="callout ok reveal">
    <h4>Pattern from demo-app</h4>
    <p>Router procedures do not define shapes inline. They import shared schemas from
    <span class="c">src/types/task.ts</span>, so input validation, return contracts, and client types stay synced.
    This is contract-first in practice.</p>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê SINGLE SOURCE OF TRUTH FLOW ‚ïê‚ïê‚ïê -->
<div class="slide reveal" data-num="04.5">
  <div class="slide-label"><span class="line"></span> demo-app pattern</div>
  <h2>Single source of truth: type flow</h2>
  <p>
    In <span class="c">@demo-app</span>, we used a contract-first pattern: define contracts once, then implement routers and UI against them.
  </p>

  <div class="steps reveal-stagger">
    <div class="step"><span class="step-n">1</span> prisma/schema.prisma</div>
    <span class="step-arr">&rarr;</span>
    <div class="step"><span class="step-n">2</span> generated/zod + prisma</div>
    <span class="step-arr">&rarr;</span>
    <div class="step"><span class="step-n">3</span> src/types/task.ts</div>
    <span class="step-arr">&rarr;</span>
    <div class="step"><span class="step-n">4</span> taskRouter</div>
    <span class="step-arr">&rarr;</span>
    <div class="step highlight"><span class="step-n">5</span> React hooks + UI</div>
  </div>

  <div class="cols" style="margin-top:1.5rem;">
    <div class="reveal">
      <h3>Shared types + router contracts</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">src/types/task.ts + src/server/api/routers/task.ts</span>
        </div>
        <pre><span class="cm">// types/task.ts</span>
<span class="kw">export const</span> <span class="tp">TaskCreateInputSchema</span> = <span class="tp">TaskInputSchema</span>
  .<span class="fn">pick</span>({ <span class="pr">title</span>: <span class="kw">true</span>, <span class="pr">priority</span>: <span class="kw">true</span>, <span class="pr">projectId</span>: <span class="kw">true</span> })
  .<span class="fn">extend</span>({ <span class="pr">title</span>: z.<span class="fn">string</span>().<span class="fn">min</span>(<span class="num">1</span>) });

<span class="kw">export const</span> <span class="tp">TaskForListSchema</span> = <span class="tp">TaskModelSchema</span>
  .<span class="fn">omit</span>({ <span class="pr">project</span>: <span class="kw">true</span>, <span class="pr">user</span>: <span class="kw">true</span> })
  .<span class="fn">extend</span>({
  <span class="pr">project</span>: z.<span class="fn">object</span>({ <span class="pr">id</span>: z.<span class="fn">string</span>(), <span class="pr">name</span>: z.<span class="fn">string</span>() }),
  <span class="pr">user</span>: z.<span class="fn">object</span>({ <span class="pr">id</span>: z.<span class="fn">string</span>(), <span class="pr">name</span>: z.<span class="fn">string</span>() }).<span class="fn">nullable</span>(),
});

<span class="cm">// task router uses shared schemas</span>
<span class="fn">create</span>: publicProcedure.<span class="fn">input</span>(<span class="tp">TaskCreateInputSchema</span>)...
<span class="fn">getAll</span>: publicProcedure.<span class="fn">output</span>(z.<span class="fn">array</span>(<span class="tp">TaskForListSchema</span>))...</pre>
      </div>
    </div>

    <div class="reveal">
      <h3>Client receives inferred types automatically</h3>
      <div class="terminal">
        <div class="terminal-chrome">
          <div class="dots"><span></span><span></span><span></span></div>
          <span class="file">src/trpc/react.tsx + TaskList.tsx</span>
        </div>
        <pre><span class="cm">// trpc/react.tsx</span>
<span class="kw">export type</span> <span class="tp">RouterOutputs</span> =
  inferRouterOutputs&lt;<span class="tp">AppRouter</span>&gt;;

<span class="cm">// TaskList.tsx</span>
<span class="kw">type</span> <span class="tp">TaskItem</span> =
  <span class="tp">RouterOutputs</span>[<span class="str">"task"</span>][<span class="str">"getAll"</span>][<span class="num">number</span>];

<span class="kw">const</span> { <span class="pr">data</span>: tasks } = api.task.getAll.<span class="fn">useQuery</span>();
tasks?.<span class="fn">map</span>((task) =&gt; (
  &lt;<span class="tp">StatusBadge</span> <span class="pr">id</span>={task.id} <span class="pr">status</span>={task.status} /&gt;
));</pre>
      </div>
    </div>
  </div>

  <div class="callout reveal">
    <h4>Where contract-first shows up in code</h4>
    <p><span class="c">src/types/task.ts</span> defines reusable input/output contracts first.
    <span class="c">src/server/api/routers/task.ts</span> consumes those contracts via <span class="c">.input(...)</span> and <span class="c">.output(...)</span>.
    <span class="c">src/features/tasks/components/TaskList.tsx</span> consumes inferred router output types.</p>
  </div>

  <div class="callout reveal">
    <h4>What changes when schema changes?</h4>
    <p>Update Prisma once, regenerate, and TypeScript points to every broken assumption across router + components.
    That is the end-to-end single source of truth.</p>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê PROTECTED PROCEDURES ‚ïê‚ïê‚ïê -->
<div class="slide reveal" data-num="05">
  <div class="slide-label"><span class="line"></span> Quick look</div>
  <h2>Protected procedures</h2>
  <p>Auth-gate any route with <span class="c">protectedProcedure</span>. Don't deep-dive NextAuth yet ‚Äî just know the pattern.</p>

  <div class="terminal reveal">
    <div class="terminal-chrome">
      <div class="dots"><span></span><span></span><span></span></div>
      <span class="file">protectedExample.ts</span>
    </div>
    <pre><span class="cm">// Only authenticated users can call this</span>
<span class="fn">createTask</span>: <span class="tp">protectedProcedure</span>
  .<span class="fn">input</span>(z.<span class="fn">object</span>({
    <span class="pr">title</span>: z.<span class="fn">string</span>().<span class="fn">min</span>(<span class="num">1</span>),
    <span class="pr">projectId</span>: z.<span class="fn">string</span>(),
  }))
  .<span class="fn">output</span>(z.<span class="fn">object</span>({
    <span class="pr">id</span>: z.<span class="fn">string</span>(),
    <span class="pr">title</span>: z.<span class="fn">string</span>(),
    <span class="pr">projectId</span>: z.<span class="fn">string</span>(),
    <span class="pr">userId</span>: z.<span class="fn">string</span>().<span class="fn">nullable</span>(),
  }))
  .<span class="fn">mutation</span>(({ <span class="pr">ctx</span>, <span class="pr">input</span> }) =&gt; {
    <span class="cm">// ctx.session.user is guaranteed to exist</span>
    <span class="kw">return</span> ctx.db.task.<span class="fn">create</span>({
      <span class="pr">data</span>: {
        ...<span class="pr">input</span>,
        <span class="pr">userId</span>: ctx.session.user.id,
      },
    });
  }),</pre>
  </div>

  <div class="callout reveal">
    <h4>The pattern repeats</h4>
    <p>Same shape every time: Zod input &rarr; Prisma query &rarr; return.
    The client SDK is auto-generated and always in sync.</p>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê EXTENDED WORKFLOW ‚ïê‚ïê‚ïê -->
<div class="slide reveal" data-num="06">
  <div class="slide-label"><span class="line"></span> 5 min &middot; wrap up</div>
  <h2>The extended workflow</h2>

  <div class="steps reveal-stagger">
    <div class="step"><span class="step-n">1</span> Requirement</div>
    <span class="step-arr">&rarr;</span>
    <div class="step"><span class="step-n">2</span> Contract</div>
    <span class="step-arr">&rarr;</span>
    <div class="step"><span class="step-n">3</span> Implement Router</div>
    <span class="step-arr">&rarr;</span>
    <div class="step highlight"><span class="step-n">4</span> Build UI</div>
    <span class="step-arr">&rarr;</span>
    <div class="step ghost"><span class="step-n">5</span> Regenerate + Verify</div>
  </div>

  <blockquote class="reveal">
    After today, your backend is done for any feature. The pattern is always the same.
  </blockquote>

  <div class="assignment reveal">
    <h3>// Today's assignment</h3>
    <ul>
      <li>Build routers for every model in your schema ‚Äî full CRUD</li>
      <li>Add at least one filtered query (tasks by project, tasks by priority)</li>
      <li>Add Zod input validation to every mutation</li>
      <li>Test procedures using Prisma Studio to verify data</li>
    </ul>
    <div class="stretch">
      <div class="stretch-label">Stretch</div>
      <ul>
        <li>Add a <span class="c">protectedProcedure</span> and read the NextAuth T3 docs</li>
        <li>Explore TanStack Query docs for Day 3</li>
      </ul>
    </div>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê BOTTOM NAV ‚ïê‚ïê‚ïê -->
<div class="end-slide">
  <div class="page-nav">
    <a href="index.html">
      <span class="pn-label">&larr; Previous</span>
      <span class="pn-title">Day 1: Schema-First Development</span>
    </a>
    <a href="day3.html">
      <span class="pn-label">Next &rarr;</span>
      <span class="pn-title">Day 3: Frontend + Full Loop</span>
    </a>
  </div>

  <footer>
    <div class="f-links">
      <a href="index.html">Day 1: Schema</a>
      <a href="day2.html">Day 2: tRPC</a>
      <a href="day3.html">Day 3: Frontend</a>
    </div>
    <p>T3 Stack Workshop &mdash; Lyra Fellowship</p>
  </footer>
</div>
</main>

<script>
const io = new IntersectionObserver((entries) => {
  entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('vis'); });
}, { threshold: 0.08 });
document.querySelectorAll('.reveal, .reveal-stagger').forEach(el => io.observe(el));
</script>

</body>
</html>
